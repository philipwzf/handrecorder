<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BBO Handviewer Workbench — Side‑by‑Side</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --gap: 12px;
      --panel-bg: #f7f7fb;
      --border: #d9d9e3;
      --accent: #5b6cff;
      /* right panel (preview) width percentage; JS updates this */
      --right: 60%;
    }
    *{ box-sizing: border-box; }
    body{
      margin:0;
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:#111;
      background:#fff;
      height:100vh;
      display:flex;
      flex-direction:column;
    }
    header{
      padding:12px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    header h1{
      font-size:16px;
      margin:0 12px 0 0;
      font-weight:600;
      white-space:nowrap;
    }
    .small{ opacity:.75; font-size:12px; }
    .pill{
      border:1px dashed var(--border);
      border-radius:99px; padding:6px 10px; font-size:12px; color:#444;
    }

    /* NEW: side‑by‑side grid */
    .container{
      display:grid;
      grid-template-columns: calc(100% - var(--right)) var(--right);
      grid-template-rows: 1fr;
      height:calc(100vh - 57px);
    }
    .left{
      padding:16px;
      overflow:auto;
      background:var(--panel-bg);
      border-right:1px solid var(--border);
    }
    .right{
      position:relative;
      min-height:180px;
    }
    iframe{
      position:absolute; inset:0; width:100%; height:100%; border:0;
      background:#fff;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: var(--gap);
      margin-bottom: var(--gap);
      align-items:center;
    }
    .controls input[type="text"]{
      width:100%;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:8px;
      font-size:14px;
      background:#fff;
    }
    .btn{
      appearance:none; border:1px solid var(--border); background:#fff;
      border-radius:8px; padding:10px 12px; cursor:pointer; font-weight:600;
    }
    .btn.primary{ background: var(--accent); color:#fff; border-color: transparent; }

    .bar{ display:flex; gap:8px; align-items:center; margin-bottom:12px; }
    .bar input[type="range"]{ width:220px; }
    .muted{ opacity:.8; }

    .grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: var(--gap);
    }
    fieldset{
      border:1px solid var(--border);
      border-radius:10px;
      padding:12px;
      background:#fff;
      min-width:0;
    }
    legend{ padding: 0 6px; font-weight:700; color:#333; }
    label{ display:block; font-size:12px; margin-bottom:6px; color:#333; font-weight:600; }
    .row{ display:grid; grid-template-columns: repeat(4, 1fr); gap: var(--gap); }

    input[type="text"], textarea, select, input[type="number"]{
      width:100%; padding:9px 10px; border:1px solid var(--border); border-radius:8px; font: inherit; background:#fff;
    }
    textarea{ resize:vertical; min-height:48px; }
    .hint{ font-size:12px; color:#555; margin-top:6px; }
    .generated{ display:flex; gap:8px; align-items:center; margin-top:8px; }
    .generated input{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }
    .bad{ outline:2px solid #ff4d4f; }

    /* BBO-style layout for the popup play recorder*/
    .bbo-bridge-container {
      position: relative;
      width: 100%;
      max-width: 600px;
      height: 400px;
      margin: 20px auto;
      background: #f8f9fa;
      border: 2px solid #dee2e6;
      border-radius: 8px;
    }

    .bbo-hand {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      min-width: 120px;
    }

    .bbo-north {
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
    }

    .bbo-south {
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
    }

    .bbo-east {
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }

    .bbo-west {
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
    }

    .bbo-hand-label {
      font-weight: bold;
      text-align: center;
      margin-bottom: 4px;
      font-size: 12px;
      color: #666;
    }

    .bbo-hand-cards {
      font-size: 11px;
      line-height: 1.2;
    }

    .bbo-suit {
      margin-bottom: 2px;
      white-space: nowrap;
    }

    .bbo-suit:before {
      font-weight: bold;
      margin-right: 2px;
    }

    .bbo-suit.spades:before { content: "♠"; color: black; }
    .bbo-suit.hearts:before { content: "♥"; color: red; }
    .bbo-suit.diamonds:before { content: "♦"; color: red; }
    .bbo-suit.clubs:before { content: "♣"; color: black; }

    .bbo-card {
      cursor: pointer;
      padding: 1px 2px;
      margin: 0 1px;
      border-radius: 2px;
      font-family: monospace;
      font-weight: bold;
    }

    .bbo-card.playable {
      background: #e3f2fd;
      border: 1px solid #2196f3;
    }

    .bbo-card.playable:hover {
      background: #bbdefb;
    }

    .bbo-card.played {
      opacity: 0.4;
      cursor: not-allowed;
      text-decoration: line-through;
    }

    .bbo-card.spades, .bbo-card.clubs { color: black; }
    .bbo-card.hearts, .bbo-card.diamonds { color: red; }

    .bbo-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 140px;
      height: 100px;
      text-align: center;
    }

    .bbo-trick-area {
      position: relative;
      width: 100px;
      height: 70px;
      margin: 0 auto 8px;
      background: rgba(255,255,255,0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .bbo-played-card {
      position: absolute;
      display: none;
      font-size: 12px;
      font-weight: bold;
      background: white;
      border: 1px solid #333;
      border-radius: 3px;
      padding: 2px 4px;
      min-width: 20px;
      text-align: center;
    }

    .bbo-north-card { top: 2px; left: 50%; transform: translateX(-50%); }
    .bbo-south-card { bottom: 2px; left: 50%; transform: translateX(-50%); }
    .bbo-east-card { right: 2px; top: 50%; transform: translateY(-50%); }
    .bbo-west-card { left: 2px; top: 50%; transform: translateY(-50%); }

    .bbo-trick-info {
      font-size: 11px;
      color: #666;
      text-align: center;
    }

    .bbo-controls {
      display: flex;
      gap: 8px;
      margin: 16px 0;
      justify-content: center;
      flex-wrap: wrap;
    }

    .bbo-controls .btn {
      padding: 8px 12px;
      font-size: 12px;
    }

    /* Play Recorder Popup Styles */
    .play-recorder-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .play-recorder-popup {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 90vh;
      overflow: auto;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
    }

    .play-recorder-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--panel-bg);
      border-radius: 12px 12px 0 0;
    }

    .play-recorder-content {
      padding: 20px;
    }

    .sequence-display {
      font-family: monospace;
      background: white;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      min-height: 60px;
      overflow-y: auto;
      margin-top: 8px;
    }

    /* Mobile: stack vertically */
    @media (max-width: 980px){
      .container{
        grid-template-columns: 1fr;
        grid-template-rows: 50% 50%;
      }
      .left{ border-right:0; border-bottom:1px solid var(--border); }
      .grid{ grid-template-columns: 1fr; }
      .row{ grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>BBO Handviewer Workbench</h1>
    <div class="small">Paste a Handviewer link → edit parts → preview on the right.</div>
    <div class="pill">Docs: bridgebase.com/tools/hvdoc.html</div>
  </header>

  <div class="container" id="container">
    <!-- LEFT: settings -->
    <section class="left">
      <!-- IMPORTER -->
      <fieldset style="margin-bottom:12px;">
        <legend>Import results & extract Handviewer links</legend>
        <div class="grid" style="grid-template-columns: 1fr; gap: var(--gap);">

          <div>
            <label for="resultHtml">Paste the page HTML</label>
            <textarea id="resultHtml" placeholder="Paste the HTML source of the results page here"></textarea>
          </div>

          <div class="row" style="grid-template-columns: 1fr auto auto; align-items:end;">
            <div>
              <label for="filePick">Or pick a saved .html file</label>
              <input id="filePick" type="file" accept=".html,.htm,text/html" />
            </div>
            <button class="btn" id="btnExtract">Extract from pasted</button>
            <button class="btn" id="btnClearList">Clear list</button>
          </div>

          <div class="bar" style="margin-top:4px;">
            <span class="muted" id="foundCount">No links yet.</span>
            <button class="btn ghost" id="btnCopyAll" style="display:none;">Copy all</button>
          </div>

          <div class="list" id="foundList" aria-live="polite"></div>

          <div class="hint">
            We detect any <code>handviewer.html</code> link with <code>?lin=</code> or explicit <code>n/e/s/w/a/p</code> params (also <code>myhand</code> / <code>linurl</code>).
            Links are normalized to the official endpoint: <code>https://www.bridgebase.com/tools/handviewer.html</code> per the Handviewer docs.
          </div>
        </div>
      </fieldset>
      <div class="controls">
        <input id="inputLink" type="text" placeholder="Paste a BBO Handviewer link (e.g., https://www.bridgebase.com/tools/handviewer.html?n=...&a=...)" />
        <div style="display:flex; gap:8px;">
          <button class="btn" id="btnParse">Parse link</button>
          <button class="btn" id="btnExample">Load example</button>
        </div>
      </div>

      <div class="bar">
        <label for="widthRange" class="muted">Preview width</label>
        <input id="widthRange" type="range" min="35" max="85" value="60" />
        <span id="widthVal" class="muted">60%</span>
      </div>

      <div class="grid">
        <fieldset style="grid-column: span 12;">
          <legend>Hands</legend>
          <div>
            <label for="nHand">North</label>
            <input id="nHand" type="text" placeholder="e.g. sAKQ hT98 dJ7 cA654" />
          </div>
          <div>
            <label for="eHand">East</label>
            <input id="eHand" type="text" placeholder="e.g. s... h... d... c..." />
          </div>
          <div>
            <label for="sHand">South</label>
            <input id="sHand" type="text" placeholder="e.g. s... h... d... c..." />
          </div>
          <div>
            <label for="wHand">West</label>
            <input id="wHand" type="text" placeholder="e.g. s... h... d... c..." />
          </div>
          <div class="hint">
            Use suit‑prefixed blobs (order s,h,d,c). Parameters map to <code>n</code>/<code>e</code>/<code>s</code>/<code>w</code> in the official Handviewer query format.
          </div>
        </fieldset>

        <fieldset style="grid-column: span 12;">
          <legend>Auction</legend>
          <label for="auction">Calls</label>
          <input id="auction" type="text" placeholder="e.g. 1s p 2s p 4s p p p" />
          <div class="hint">Space/comma separated. Use N for notrump (e.g., 1N), X for double, R for redouble.</div>
        </fieldset>

        <fieldset style="grid-column: span 12;">
          <legend>Play</legend>
          <label for="play">Cards (lead first)</label>
          <textarea id="play" placeholder="e.g. sj sq sk sa da c2 d4 d3"></textarea>
          <div class="hint">Cards are suit+rank: sj, h9, da, ct…</div>
          <button class="btn" type="button" onclick="playRecorder.open()" style="margin-top: 8px;">
            🃏 Open Play Recorder
          </button>
        </fieldset>

        <fieldset style="grid-column: span 12;">
          <legend>Board Settings</legend>
            <div>
              <label for="dealer">Dealer</label>
              <select id="dealer">
                <option value="">(auto/unspecified)</option>
                <option value="n">North</option>
                <option value="e">East</option>
                <option value="s">South</option>
                <option value="w">West</option>
              </select>
            </div>
            <div>
              <label for="vul">Vulnerability</label>
              <select id="vul">
                <option value="">(none specified)</option>
                <option value="-">None</option>
                <option value="n">NS</option>
                <option value="e">EW</option>
                <option value="b">Both</option>
              </select>
            </div>
            <div>
              <label for="board">Board #</label>
              <input id="board" type="number" min="1" step="1" placeholder="e.g. 7" />
            </div>
            <div>
              <label for="claim">Claimed tricks</label>
              <input id="claim" type="number" min="0" step="1" placeholder="optional" />
            </div>

          <div class="generated">
            <label for="outputLink" style="margin:0;">Generated viewer link</label>
            <input id="outputLink" type="text" readonly />
            <button class="btn" id="btnCopy">Copy</button>
            <button class="btn primary" id="btnApply">Update Preview</button>
          </div>
          <div class="hint">
            Links are built per the Handviewer spec (params: n/e/s/w, a, p, d, v, b, c). See the docs in the header.
          </div>
        </fieldset>
      </div>
    </section>

    <!-- RIGHT: preview -->
    <section class="right">
      <iframe id="viewer" title="BBO Handviewer Preview"
              src="about:blank" allowfullscreen referrerpolicy="no-referrer"></iframe>
    </section>
  </div>

  <script>
    // ======= Utilities =======
    const $ = sel => document.querySelector(sel);
    const dec = s => { try { return decodeURIComponent(s); } catch { return s; } };
    const trim = s => (s||"").trim();
    const nonEmpty = v => v !== undefined && v !== null && String(v).trim() !== "";

    // Debounce for live updates
    const debounce = (fn, ms=350) => { let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args),ms); }; };

    // ======= Handviewer Link Extraction =======
    function extractHandviewerLinks(htmlContent) {
      const links = [];
      
      // Pattern to match handviewer URLs
      const patterns = [
        /https?:\/\/[^\/]*bridgebase\.com\/tools\/handviewer\.html\?[^"'\s<>]*/gi,
        /\/\/[^\/]*bridgebase\.com\/tools\/handviewer\.html\?[^"'\s<>]*/gi,
        /handviewer\.html\?[^"'\s<>]*/gi
      ];
      
      patterns.forEach((pattern, index) => {
        console.log(`Testing pattern ${index + 1}:`, pattern);
        const matches = htmlContent.match(pattern) || [];
        console.log(`Pattern ${index + 1} found ${matches.length} matches:`, matches);
        
        matches.forEach(match => {
          console.log('Processing match:', match);
          let url = match;
          if (url.startsWith('//')) {
            url = 'https:' + url;
          } else if (url.startsWith('handviewer.html')) {
            url = 'https://www.bridgebase.com/tools/' + url;
          }
          
          console.log('Normalized URL:', url);
          const isValid = isValidHandviewerLink(url);
          console.log('Is valid:', isValid);
          
          if (isValid) {
            links.push(url);
          }
        });
      });

      return [...new Set(links)]; // Remove duplicates
    }
    function isValidHandviewerLink(url) {
      try {
        const urlObj = new URL(url);
        const params = urlObj.searchParams;
        
        const hasHandParams = params.has('n') || params.has('e') || params.has('s') || params.has('w');
        const hasOtherParams = params.has('lin') || params.has('myhand') || params.has('linurl');
        const hasAuctionPlay = params.has('a') || params.has('p');
        
        return hasHandParams || hasOtherParams || hasAuctionPlay;
      } catch {
        return false;
      }
    }

    function extractBoardInfo(url) {
      try {
        const urlObj = new URL(url);
        const params = urlObj.searchParams;
        
        let boardNum = params.get('b') || '';
        let players = {
          north: params.get('nn') || '',
          south: params.get('sn') || '',
          east: params.get('en') || '',
          west: params.get('wn') || ''
        };
        
        return {
          url: url,
          boardNumber: boardNum,
          players: players
        };
      } catch {
        return {
          url: url,
          boardNumber: '',
          players: { north: '', south: '', east: '', west: '' }
        };
      }
    }

    function displayFoundLinks(links) {
          const foundList = $('#foundList');
          const foundCount = $('#foundCount');
          const btnCopyAll = $('#btnCopyAll');
          
          if (links.length === 0) {
            foundCount.textContent = 'No handviewer links found.';
            foundList.innerHTML = '';
            btnCopyAll.style.display = 'none';
            return;
          }
          
          // Store links globally for pagination
          window.allFoundLinks = links;
          window.currentPage = 1;
          window.itemsPerPage = parseInt(localStorage.getItem('linksPerPage') || '10');
          
          renderPaginatedLinks();
        }

    function renderPaginatedLinks() {
  const links = window.allFoundLinks || [];
  const currentPage = window.currentPage || 1;
  const itemsPerPage = window.itemsPerPage || 10;
  
  const foundList = $('#foundList');
  const foundCount = $('#foundCount');
  const btnCopyAll = $('#btnCopyAll');
  
  // Calculate pagination
  const totalPages = Math.ceil(links.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = Math.min(startIndex + itemsPerPage, links.length);
  const currentLinks = links.slice(startIndex, endIndex);
  
  // Update count and show copy all button
  foundCount.textContent = `Found ${links.length} handviewer link${links.length === 1 ? '' : 's'}`;
  btnCopyAll.style.display = 'inline-block';
  
  // Create pagination controls
  const paginationHtml = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px; background: #f5f5f5; border-radius: 6px;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="font-size: 12px; color: #666;">Show:</span>
        <select id="itemsPerPageSelect" style="padding: 4px 6px; border: 1px solid var(--border); border-radius: 4px; font-size: 12px;">
          <option value="1" ${itemsPerPage === 1 ? 'selected' : ''}>1</option>
          <option value="5" ${itemsPerPage === 5 ? 'selected' : ''}>5</option>
          <option value="10" ${itemsPerPage === 10 ? 'selected' : ''}>10</option>
          <option value="25" ${itemsPerPage === 25 ? 'selected' : ''}>25</option>
          <option value="50" ${itemsPerPage === 50 ? 'selected' : ''}>50</option>
        </select>
        <span style="font-size: 12px; color: #666;">per page</span>
      </div>
      <div style="display: flex; align-items: center; gap: 8px;">
        <span style="font-size: 12px; color: #666;">
          Showing ${startIndex + 1}-${endIndex} of ${links.length}
        </span>
        <div style="display: flex; gap: 4px; align-items: center;">
          <button class="btn" style="padding: 4px 8px; font-size: 11px;" 
                  onclick="changePage(${currentPage - 1})" 
                  ${currentPage === 1 ? 'disabled' : ''}>‹ Prev</button>
          <span style="padding: 4px 8px; font-size: 11px; color: #666;">
            Page
          </span>
          <input id="pageJumpInput" type="number" min="1" max="${totalPages}" value="${currentPage}" 
                 style="width: 50px; padding: 2px 4px; border: 1px solid var(--border); border-radius: 4px; font-size: 11px; text-align: center;"
                 onkeypress="handlePageJump(event, ${totalPages})" />
          <span style="padding: 4px 8px; font-size: 11px; color: #666;">
            of ${totalPages}
          </span>
          <button class="btn" style="padding: 4px 8px; font-size: 11px;" 
                  onclick="changePage(${currentPage + 1})" 
                  ${currentPage === totalPages ? 'disabled' : ''}>Next ›</button>
        </div>
      </div>
    </div>
  `;
  
  // Create links HTML
  const linksHtml = currentLinks.map((link, index) => {
    const globalIndex = startIndex + index;
    const info = extractBoardInfo(link);
    const boardText = info.boardNumber ? `Board ${info.boardNumber}` : `Link ${globalIndex + 1}`;
    const playersText = info.players.north || info.players.south ? 
      ` - ${info.players.north} & ${info.players.south} vs ${info.players.east} & ${info.players.west}` : '';
    
    return `
      <div style="border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin-bottom: 8px; background: #fff;">
        <div style="display: flex; justify-content: space-between; align-items: start; gap: 12px;">
          <div style="flex: 1; min-width: 0;">
            <div style="font-weight: 600; margin-bottom: 4px;">${boardText}${playersText}</div>
            <div style="font-family: ui-monospace, monospace; font-size: 12px; color: #666; word-break: break-all;">
              ${link}
            </div>
          </div>
          <div style="display: flex; gap: 8px; flex-shrink: 0;">
            <button class="btn" style="padding: 6px 10px; font-size: 12px;" onclick="loadHandviewerLink('${link.replace(/'/g, "\\'")}')">Load</button>
            <button class="btn" style="padding: 6px 10px; font-size: 12px;" onclick="copyToClipboard('${link.replace(/'/g, "\\'")}')">Copy</button>
          </div>
        </div>
      </div>
    `;
  }).join('');
  
  foundList.innerHTML = paginationHtml + linksHtml;
  
  // Add event listener for items per page change
  const select = $('#itemsPerPageSelect');
  if (select) {
    select.addEventListener('change', (e) => {
      window.itemsPerPage = parseInt(e.target.value);
      window.currentPage = 1; // Reset to first page
      localStorage.setItem('linksPerPage', window.itemsPerPage);
      renderPaginatedLinks();
    });
  }
}

    function handlePageJump(event, totalPages) {
  if (event.key === 'Enter') {
    const pageInput = event.target;
    const newPage = parseInt(pageInput.value);
    
    if (newPage >= 1 && newPage <= totalPages) {
      changePage(newPage);
    } else {
      // Reset to current page if invalid
      pageInput.value = window.currentPage || 1;
      // Optional: show a brief error indication
      pageInput.style.borderColor = '#ff4d4f';
      setTimeout(() => {
        pageInput.style.borderColor = 'var(--border)';
      }, 1000);
    }
  }
}
        // Add pagination functions
    function changePage(newPage) {
          const totalPages = Math.ceil((window.allFoundLinks || []).length / (window.itemsPerPage || 10));
          if (newPage >= 1 && newPage <= totalPages) {
            window.currentPage = newPage;
            renderPaginatedLinks();
          }
        }

        // Also update the copyAllLinks function to work with all links, not just visible ones:
    async function copyAllLinks() {
          const links = window.allFoundLinks || [];
          
          if (links.length > 0) {
            const allLinks = links.join('\n');
            await copyToClipboard(allLinks);
            $('#btnCopyAll').textContent = 'Copied!';
            setTimeout(() => $('#btnCopyAll').textContent = 'Copy all', 1200);
          }
        }

    function loadHandviewerLink(url) {
          $('#inputLink').value = url;
          parseLink();
        }

    async function copyToClipboard(text) {
          try {
            await navigator.clipboard.writeText(text);
          } catch (err) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
          }
        }

        // Event handlers for the import section
        $('#btnExtract').addEventListener('click', () => {
          const htmlContent = $('#resultHtml').value.trim();
          if (!htmlContent) {
            alert('Please paste some HTML content first.');
            return;
          }
          
          const links = extractHandviewerLinks(htmlContent);
          displayFoundLinks(links);
        });

        $('#btnClearList').addEventListener('click', () => {
          $('#foundList').innerHTML = '';
          $('#foundCount').textContent = 'No links yet.';
          $('#btnCopyAll').style.display = 'none';
          $('#resultHtml').value = '';
        });

        $('#btnCopyAll').addEventListener('click', copyAllLinks);

        $('#filePick').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (event) => {
            $('#resultHtml').value = event.target.result;
            const links = extractHandviewerLinks(event.target.result);
            displayFoundLinks(links);
          };
          reader.readAsText(file);
        });

    // Normalize a hand string to "s...h...d...c..." lowercase
    function normalizeHand(str){
      if(!str) return "";
      let s = str.replace(/\s+/g,"");
      s = s.replace(/S/g,'s').replace(/H/g,'h').replace(/D/g,'d').replace(/C/g,'c');
      s = s.replace(/[|,]/g,'');
      s = s.replace(/10/g, 't');
      return s;
    }

    // Parse auction "1s p 2h x p p p" -> "1sp2hxppp"
    function normalizeAuction(str){
      if(!str) return "";
      let tokens = str.replace(/[|]/g,' ')
                      .replace(/,/g,' ')
                      .trim().split(/\s+/).filter(Boolean);
      const out = tokens.map(tok=>{
        let t = tok.toUpperCase().replace(/NT/g,'N');
        if(/^PASS$/i.test(t)) t='P';
        if(/^(DBL|DOUBLE)$/i.test(t)) t='X';
        if(/^(RDBL|REDOUBLE)$/i.test(t)) t='R';
        return t.toLowerCase();
      }).join('');
      return out;
    }

    // Parse play "sj sq sk sa" etc. -> "sjsqsksa"
    function normalizePlay(str){
      if(!str) return "";
      let tokens = str.replace(/[|,]/g,' ')
                      .trim().split(/\s+/).filter(Boolean);
      let ok = /^[shdc][2-9tjqka]$/i;
      let bad = false;
      tokens = tokens.map(t=>{
        let x = t.toLowerCase();
        x = x.replace(/10/g,'t');
        if(!ok.test(x)) bad = true;
        return x;
      });
      $('#play').classList.toggle('bad', bad);
      return tokens.join('');
    }

    // Build the viewer URL from current fields
    function buildUrl(){
      const base = 'https://www.bridgebase.com/tools/handviewer.html';
      const params = new URLSearchParams();

      const n = normalizeHand($('#nHand').value);
      const e = normalizeHand($('#eHand').value);
      const s = normalizeHand($('#sHand').value);
      const w = normalizeHand($('#wHand').value);
      const a = normalizeAuction($('#auction').value);
      const p = normalizePlay($('#play').value);
      const d = $('#dealer').value;
      const v = $('#vul').value;
      const b = trim($('#board').value);
      const c = trim($('#claim').value);

      if(nonEmpty(n)) params.set('n', n);
      if(nonEmpty(e)) params.set('e', e);
      if(nonEmpty(s)) params.set('s', s);
      if(nonEmpty(w)) params.set('w', w);
      if(nonEmpty(a)) params.set('a', a);
      if(nonEmpty(p)) params.set('p', p);
      if(nonEmpty(d)) params.set('d', d);
      if(nonEmpty(v)) params.set('v', v);
      if(nonEmpty(b)) params.set('b', b);
      if(nonEmpty(c)) params.set('c', c);

      const url = params.toString() ? `${base}?${params.toString()}` : base;
      $('#outputLink').value = url;
      return url;
    }

    function applyToViewer(){ $('#viewer').src = $('#outputLink').value || 'about:blank'; }
    const applyDebounced = debounce(()=>{ buildUrl(); applyToViewer(); }, 500);

    // ======= Parsing a pasted Handviewer link =======
    function parseLink(){
      const raw = trim($('#inputLink').value);
      if(!raw) return;

      let href = raw;
      if(/^\/\//.test(href)) href = 'https:' + href;
      if(/^\?/.test(href)) href = 'https://www.bridgebase.com/tools/handviewer.html' + href;

      let u;
      try{ u = new URL(href); }catch(e){
        alert('That does not look like a valid URL.');
        return;
      }
      const sp = u.searchParams;

      const fill = (id, key) => { 
        if(sp.get(key)) {
          let value = dec(sp.get(key));
          if(['n', 'e', 's', 'w', 'p'].includes(key)) {
            value = value.replace(/10/g, 't');
          }
          $(id).value = value;

        }
      };

      // Reset first
      ['#nHand','#eHand','#sHand','#wHand','#auction','#play','#board','#claim'].forEach(id => $(id).value = '');
      ['#dealer','#vul'].forEach(id => $(id).value = '');

      if(sp.has('n') || sp.has('s') || sp.has('e') || sp.has('w') || sp.has('a') || sp.has('p')){
        fill('#nHand','n'); fill('#eHand','e'); fill('#sHand','s'); fill('#wHand','w');
        fill('#auction','a'); fill('#play','p');
        fill('#board','b'); fill('#claim','c');
        if(sp.get('d')) $('#dealer').value = sp.get('d').toLowerCase();
        if(sp.get('v')) $('#vul').value    = sp.get('v').toLowerCase();
        buildUrl(); applyToViewer();
        return;
      }

      if(sp.has('lin')){
        const lin = dec(sp.get('lin'));
        parseLinStringIntoFields(lin);
        buildUrl(); applyToViewer();
        return;
      }

      if(sp.has('myhand') || sp.has('linurl')){
        $('#outputLink').value = href;
        applyToViewer();
        alert('This link references a remote movie (myhand/linurl). I can preview it on the right, but cannot parse it into editable fields.');
        return;
      }

      alert('Could not find recognizable Handviewer parameters in that link.');
    }

    // Parse a LIN movie string into our editable fields
    function parseLinStringIntoFields(lin){
      const t = lin.split('|');
      const bids = [];
      const plays = [];
      let claim = '';
      let dealerDigit = null;
      let sHand='', wHand='', nHand='', eHand='';
      let vul='', board='';

      for(let i=0; i<t.length; i+=2){
        const tag = (t[i]||'').trim().toLowerCase();
        const val = (t[i+1]||'').trim();

        if(!tag) { i -= 1; continue; }

        if(tag === 'md'){
          if(val.length){
            dealerDigit = val[0];
            const body = val.slice(1);
            const parts = body.split(',');
            sHand = normalizeHand(parts[0]||'');
            wHand = normalizeHand(parts[1]||'');
            nHand = normalizeHand(parts[2]||'');
            eHand = normalizeHand(parts[3]||'');
          }
        }
        else if(tag === 'sv'){ vul = val.toLowerCase(); }
        else if(tag === 'ah'){ const m = /board\s+(\d+)/i.exec(val); if(m) board = m[1]; }
        else if(tag === 'mb'){ bids.push(val.toUpperCase().replace(/NT/g,'N').toLowerCase()); }
        else if(tag === 'pc'){ 
          let playCard = val.toLowerCase().replace(/10/g,'t');
          plays.push(val.toLowerCase()); 
        }
        else if(tag === 'mc'){ claim = val; }
      }

      const dealerMap = { '1':'s', '2':'w', '3':'n', '4':'e' };
      const d = dealerMap[String(dealerDigit)] || '';

      $('#nHand').value = nHand; $('#eHand').value = eHand; $('#sHand').value = sHand; $('#wHand').value = wHand;
      $('#auction').value = bids.join(' ');
      $('#play').value    = plays.join(' ');
      $('#dealer').value = d || '';
      $('#vul').value    = vul || '';
      $('#board').value  = board || '';
      $('#claim').value  = claim || '';
    }
    // Replace the PlayRecorder class with this enhanced version:

    class PlayRecorder {
      constructor() {
        this.hands = { n: '', e: '', s: '', w: '' };
        this.playSequence = [];
        this.playedBy = []; // NEW: Track who played each card
        this.currentPlayer = 0; // 0=N, 1=E, 2=S, 3=W
        this.currentTrick = 0;
        this.currentTrickCards = [];
        this.leadSuit = null;
        this.declarer = 0;
        this.trumpSuit = null;
        this.createPopup();
      }


      createPopup() {
        const overlay = document.createElement('div');
        overlay.className = 'play-recorder-overlay';
        overlay.id = 'playRecorderOverlay';
        
        overlay.innerHTML = `
          <div class="play-recorder-popup" style="max-width: 900px;">
            <div class="play-recorder-header">
              <h3 style="margin: 0;">Play Recorder</h3>
              <button class="btn" onclick="playRecorder.close()">×</button>
            </div>
            <div class="play-recorder-content">
              
              <!-- BBO-style bridge table layout -->
              <div class="bbo-bridge-container">
                <!-- North hand -->
                <div class="bbo-hand bbo-north">
                  <div class="bbo-hand-label">North</div>
                  <div class="bbo-hand-cards" id="bboNorthCards">
                    <div class="bbo-suit spades" id="northSpades"></div>
                    <div class="bbo-suit hearts" id="northHearts"></div>
                    <div class="bbo-suit diamonds" id="northDiamonds"></div>
                    <div class="bbo-suit clubs" id="northClubs"></div>
                  </div>
                </div>

                <!-- West hand -->
                <div class="bbo-hand bbo-west">
                  <div class="bbo-hand-label">West</div>
                  <div class="bbo-hand-cards" id="bboWestCards">
                    <div class="bbo-suit spades" id="westSpades"></div>
                    <div class="bbo-suit hearts" id="westHearts"></div>
                    <div class="bbo-suit diamonds" id="westDiamonds"></div>
                    <div class="bbo-suit clubs" id="westClubs"></div>
                  </div>
                </div>

                <!-- Center play area -->
                <div class="bbo-center">
                  <div class="bbo-trick-area">
                    <div class="bbo-played-card bbo-north-card" id="northPlayedCard"></div>
                    <div class="bbo-played-card bbo-west-card" id="westPlayedCard"></div>
                    <div class="bbo-played-card bbo-east-card" id="eastPlayedCard"></div>
                    <div class="bbo-played-card bbo-south-card" id="southPlayedCard"></div>
                  </div>
                  <div class="bbo-trick-info">
                    <div>Trick <span id="bboTrickNumber">1</span></div>
                    <div id="bboCurrentPlayer">North to lead</div>
                  </div>
                </div>

                <!-- East hand -->
                <div class="bbo-hand bbo-east">
                  <div class="bbo-hand-label">East</div>
                  <div class="bbo-hand-cards" id="bboEastCards">
                    <div class="bbo-suit spades" id="eastSpades"></div>
                    <div class="bbo-suit hearts" id="eastHearts"></div>
                    <div class="bbo-suit diamonds" id="eastDiamonds"></div>
                    <div class="bbo-suit clubs" id="eastClubs"></div>
                  </div>
                </div>

                <!-- South hand -->
                <div class="bbo-hand bbo-south">
                  <div class="bbo-hand-label">South</div>
                  <div class="bbo-hand-cards" id="bboSouthCards">
                    <div class="bbo-suit spades" id="southSpades"></div>
                    <div class="bbo-suit hearts" id="southHearts"></div>
                    <div class="bbo-suit diamonds" id="southDiamonds"></div>
                    <div class="bbo-suit clubs" id="southClubs"></div>
                  </div>
                </div>
              </div>

              <!-- Controls -->
              <div class="bbo-controls">
                <button class="btn" onclick="playRecorder.rewind()">⏮ Rewind</button>
                <button class="btn" onclick="playRecorder.undoLastCard()">⏪ Previous</button>
                <button class="btn" onclick="playRecorder.nextCard()" id="nextCardBtn" style="display:none;">⏩ Next</button>
                <button class="btn primary" onclick="playRecorder.applyToMainForm()">✓ Apply</button>
              </div>
              
              <div style="margin-top: 16px;">
                <label><strong>Play Sequence:</strong></label>
                <div class="sequence-display" id="playSequenceDisplay"></div>
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(overlay);
      }

      // Calculate missing hand from the other 3 hands
      calculateMissingHand() {
        // Full deck of cards
        const allCards = {
          s: ['a', 'k', 'q', 'j', 't', '9', '8', '7', '6', '5', '4', '3', '2'],
          h: ['a', 'k', 'q', 'j', 't', '9', '8', '7', '6', '5', '4', '3', '2'],
          d: ['a', 'k', 'q', 'j', 't', '9', '8', '7', '6', '5', '4', '3', '2'],
          c: ['a', 'k', 'q', 'j', 't', '9', '8', '7', '6', '5', '4', '3', '2']
        };

        // Get cards from known hands
        const usedCards = new Set();
        ['n', 'e', 's', 'w'].forEach(pos => {
          if (this.hands[pos]) {
            const hand = this.parseHand(this.hands[pos]);
            Object.keys(hand).forEach(suit => {
              hand[suit].forEach(rank => {
                usedCards.add(suit + rank);
              });
            });
          }
        });

        // Find which position is missing
        let missingPos = null;
        ['n', 'e', 's', 'w'].forEach(pos => {
          if (!this.hands[pos] || this.hands[pos].trim() === '') {
            missingPos = pos;
          }
        });

        if (!missingPos) return; // All hands are present

        // Calculate remaining cards
        const remainingCards = { s: [], h: [], d: [], c: [] };
        Object.keys(allCards).forEach(suit => {
          allCards[suit].forEach(rank => {
            if (!usedCards.has(suit + rank)) {
              remainingCards[suit].push(rank);
            }
          });
        });

        // Convert back to hand string format
        let handString = '';
        ['s', 'h', 'd', 'c'].forEach(suit => {
          if (remainingCards[suit].length > 0) {
            handString += suit + remainingCards[suit].join('');
          }
        });

        this.hands[missingPos] = handString;
      }

      parseHand(handString) {
        const hand = { s: [], h: [], d: [], c: [] };
        if (!handString) return hand;

        handString = handString.replace(/10/g, 't'); // Normalize 10 to t
        
        let currentSuit = null;
        for (let i = 0; i < handString.length; i++) {
          const char = handString[i].toLowerCase();
          if (['s', 'h', 'd', 'c'].includes(char)) {
            currentSuit = char;
          } else if (currentSuit && /[2-9tjqka]/i.test(char)) {
            hand[currentSuit].push(char);
          }
        }
        
        return hand;
      }


      renderBBOHands() {
        const positions = ['n', 'e', 's', 'w'];
        const positionNames = ['north', 'east', 'south', 'west'];
        
        positions.forEach((pos, posIndex) => {
          const hand = this.parseHand(this.hands[pos]);
          const playedCards = this.getPlayedCards(posIndex);
          
          ['s', 'h', 'd', 'c'].forEach(suit => {
            const container = $(`#${positionNames[posIndex]}${suit === 's' ? 'Spades' : suit === 'h' ? 'Hearts' : suit === 'd' ? 'Diamonds' : 'Clubs'}`);
            container.innerHTML = '';
            
            if (hand[suit] && hand[suit].length > 0) {
              // Sort cards in proper order (A, K, Q, J, T, 9, 8, 7, 6, 5, 4, 3, 2)
              const sortedCards = hand[suit].sort((a, b) => {
                const order = ['a', 'k', 'q', 'j', 't', '9', '8', '7', '6', '5', '4', '3', '2'];
                return order.indexOf(a) - order.indexOf(b);
              });
              
              sortedCards.forEach(rank => {
                const cardCode = suit + rank;
                const isPlayed = playedCards.includes(cardCode);
                
                // FIX: Only check if this specific player can play, regardless of loop position
                const canPlay = !isPlayed && (posIndex === this.currentPlayer) && this.canPlayCard(posIndex, suit, rank);
                // console.log(`Rendering card ${cardCode} for player ${posIndex} (played: ${isPlayed}) (can play: ${canPlay})`);

                const cardEl = document.createElement('span');
                cardEl.className = `bbo-card ${suit}`;
                cardEl.textContent = this.formatBBOCard(rank);
                
                if (isPlayed) {
                  cardEl.classList.add('played');
                } else if (canPlay) {
                  cardEl.classList.add('playable');
                  cardEl.addEventListener('click', () => this.playCard(posIndex, cardCode));
                }
                
                container.appendChild(cardEl);
              });
            }
          });
        });
      }
      formatBBOCard(rank) {
        const rankMap = { '10': 'T','t': 'T', 'j': 'J', 'q': 'Q', 'k': 'K', 'a': 'A' };
        return rankMap[rank] || rank.toUpperCase();
      }

      getPlayedCards(playerIndex) {
        const playedCards = [];
        
        for (let i = 0; i < this.playSequence.length; i++) {
          if (this.playedBy[i] === playerIndex) {
            playedCards.push(this.playSequence[i]);
          }
        }
        
        return playedCards;
      }

      canPlayCard(playerIndex, suit, rank) {
        if (playerIndex !== this.currentPlayer) {
          console.log(`Player ${playerIndex} tried to play out of turn when it's Player ${this.currentPlayer}'s turn.`);
          return false;
        }

        const cardCode = suit + rank;
        if (this.playSequence.includes(cardCode)) return false;
        
        // If leading to trick, can play any card
        if (this.currentTrickCards.length === 0) return true;
        
        // Must follow suit if possible
        if (this.leadSuit && suit !== this.leadSuit) {
          const hand = this.parseHand(this.hands[['n','e','s','w'][playerIndex]]);
          const playedCards = this.getPlayedCards(playerIndex);
          const remainingInSuit = hand[this.leadSuit]?.filter(r => !playedCards.includes(this.leadSuit + r)) || [];
          return remainingInSuit.length === 0; // Can only play other suits if no cards in lead suit
        }
        
        return true;
      }

      playCard(playerIndex, cardCode) {
        if (!this.canPlayCard(playerIndex, cardCode[0], cardCode[1])) return;
        
        this.playSequence.push(cardCode);
        this.playedBy.push(playerIndex); // NEW: Track who played this card
        this.currentTrickCards.push(cardCode);
        
        if (this.currentTrickCards.length === 1) {
          this.leadSuit = cardCode[0];
        }
        
        // Show played card in center
        this.showPlayedCardInCenter(playerIndex, cardCode);
        
        if (this.currentTrickCards.length === 4) {
          setTimeout(() => this.completeTrick(), 200); // Delay to show all 4 cards
        } else {
          this.nextPlayer();
          // Only render when not completing a trick
          this.renderBBOHands();
          this.updateBBODisplay();
        }
        
        this.updateSequenceDisplay();
      }
      
      showPlayedCardInCenter(playerIndex, cardCode) {
        const positions = ['north', 'east', 'south', 'west'];
        const cardEl = $(`#${positions[playerIndex]}PlayedCard`);
        cardEl.innerHTML = this.formatPlayedCard(cardCode);
        cardEl.style.display = 'block';
      }

      formatPlayedCard(cardCode) {
        const suit = cardCode[0];
        const rank = cardCode[1];
        const suitSymbol = { s: '♠', h: '♥', d: '♦', c: '♣' }[suit];
        const rankDisplay = this.formatBBOCard(rank);
        const color = (suit === 'h' || suit === 'd') ? 'red' : 'black';
        
        return `<span style="color: ${color}; font-weight: bold;">${rankDisplay}${suitSymbol}</span>`;
      }

      clearCenterCards() {
        ['north', 'east', 'south', 'west'].forEach(pos => {
          $(`#${pos}PlayedCard`).style.display = 'none';
          $(`#${pos}PlayedCard`).innerHTML = '';
        });
      }

      nextPlayer() {
        this.currentPlayer = (this.currentPlayer + 1) % 4;
      }

      getRankValue(rank) {
        const values = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 't': 10, 'j': 11, 'q': 12, 'k': 13, 'a': 14 };
        return values[rank] || 0;
      }

      updateBBODisplay() {
        const playerNames = ['North', 'East', 'South', 'West'];
        $('#bboTrickNumber').textContent = this.currentTrick + 1;
        
        if (this.currentTrickCards.length === 0) {
          $('#bboCurrentPlayer').textContent = `${playerNames[this.currentPlayer]} to lead`;
        } else {
          $('#bboCurrentPlayer').textContent = `${playerNames[this.currentPlayer]} to play`;
        }
      }

      rewind() {
        this.reset();
      }

      undoLastCard() {
        if (this.playSequence.length === 0) return;
  
        this.playSequence.pop();
        this.playedBy.pop(); // NEW: Remove the player tracking too
        
        // Completely reset and rebuild state
        const tempSequence = [...this.playSequence];
        const tempPlayedBy = [...this.playedBy];
        
        this.playSequence = [];
        this.playedBy = [];
        this.currentTrick = 0;
        this.currentTrickCards = [];
        this.currentPlayer = this.getLeader(); // Reset to leader
        this.leadSuit = null;
        
        this.clearCenterCards();
        
        // Reprocess remaining cards
        tempSequence.forEach((card, index) => {
          this.playSequence.push(card);
          this.playedBy.push(tempPlayedBy[index]);
          this.currentTrickCards.push(card);
          
          if (this.currentTrickCards.length === 1) {
            this.leadSuit = card[0];
          }
          this.showPlayedCardInCenter(tempPlayedBy[index], card);

          if (this.currentTrickCards.length === 4) {
            this.completeTrick();
          } else {
            this.nextPlayer();
          }
        });
        
        this.renderBBOHands();
        this.updateBBODisplay();
        this.updateSequenceDisplay();
      }
      // Add this new method to parse concatenated auction strings:
parseAuctionString(auctionStr) {
  const calls = [];
  let i = 0;
  
  while (i < auctionStr.length) {
    // Try to match pass
    if (auctionStr.substr(i, 4) === 'pass') {
      calls.push('p');
      i += 4;
    } else if (auctionStr[i] === 'p') {
      calls.push('p');
      i += 1;
    }
    // Try to match double/redouble
    else if (auctionStr.substr(i, 4) === 'rdbl') {
      calls.push('r');
      i += 4;
    } else if (auctionStr.substr(i, 3) === 'dbl') {
      calls.push('x');
      i += 3;
    } else if (auctionStr[i] === 'x') {
      calls.push('x');
      i += 1;
    } else if (auctionStr[i] === 'r') {
      calls.push('r');
      i += 1;
    }
    // Try to match bids (level + strain)
    else if (/[1-7]/.test(auctionStr[i])) {
      const level = auctionStr[i];
      i += 1;
      
      // Look for strain after level
      if (i < auctionStr.length) {
        if (auctionStr.substr(i, 2) === 'nt') {
          calls.push(level + 'n');
          i += 2;
        } else if (['c', 'd', 'h', 's', 'n'].includes(auctionStr[i])) {
          calls.push(level + auctionStr[i]);
          i += 1;
        } else {
          // Invalid strain, skip
          i += 1;
        }
      }
    }
    // Skip unrecognized characters
    else {
      i += 1;
    }
  }
  
  return calls;
}

      getDeclarer() {
        const auction = $('#auction').value.trim();
        if (!auction) return null; // return null if no auction

        const dealerMap = { 'n': 0, 'e': 1, 's': 2, 'w': 3 };
        const dealer = dealerMap[$('#dealer').value] || 0;
        
        // Split auction into calls
        let calls = [];
        if (auction.includes(' ')) {
          // Space-separated format: "p p 3n p p p"
          calls = auction.toLowerCase().split(/\s+/).filter(call => call);
        } else {
          // Concatenated format: "pp3nppp" - need to parse individual calls
          calls = this.parseAuctionString(auction.toLowerCase());
        }
        console.log('Auction calls:', calls);
        if (calls.length === 0) return dealer;
        
        // Find the last actual bid (not pass/double/redouble)
        let finalContract = null;
        let finalBidIndex = -1;
        
        for (let i = calls.length - 1; i >= 0; i--) {
          const call = calls[i];
          // Skip passes, doubles, redoubles
          if (['p', 'pass', 'x', 'xx', 'd', 'r', 'dbl', 'rdbl'].includes(call)) {
            continue;
          }
          
          // Check if it's a valid bid (level + strain)
          if (call.length >= 2) {
            const level = parseInt(call[0]);
            const strain = call.substring(1);
            
            if (level >= 1 && level <= 7 && ['c', 'd', 'h', 's', 'n', 'nt'].includes(strain)) {
              finalContract = { level, strain, call };
              finalBidIndex = i;
              break;
            }
          }
        }
        console.log('Final contract search:', finalContract, finalBidIndex);
        
        if (!finalContract) return dealer; // No valid contract found

        // Set trump suit based on final contract
        if (finalContract.strain === 'n' || finalContract.strain === 'nt') {
          this.trumpSuit = null; // No trump
        } else {
          this.trumpSuit = finalContract.strain; // c, d, h, or s
        }
        
        console.log('Final contract:', finalContract, 'at position', finalBidIndex);
        
        // Determine which side won the contract
        const finalBidder = (dealer + finalBidIndex) % 4;
        const winningSide = finalBidder % 2; // 0 = NS, 1 = EW
        
        console.log('Final bidder:', ['N','E','S','W'][finalBidder], 'Winning side:', winningSide === 0 ? 'NS' : 'EW');
        
        // Find the first player from the winning side to bid the final strain
        for (let i = 0; i < calls.length; i++) {
          const call = calls[i];
          
          // Skip non-bids
          if (['p', 'pass', 'x', 'xx', 'd', 'r', 'dbl', 'rdbl'].includes(call)) {
            continue;
          }
          
          if (call.length >= 2) {
            const strain = call.substring(1);
            const bidder = (dealer + i) % 4;
            const bidderSide = bidder % 2;
            console.log(`Call ${i}: "${call}" by ${['N','E','S','W'][bidder]} (side ${bidderSide}), strain: "${strain}"`);

            // Check if same strain and same side as final contract
            if (strain === finalContract.strain && bidderSide === winningSide) {
              console.log('Declarer found:', ['N','E','S','W'][bidder], 'first to bid', strain, 'from winning side');
              return bidder;
            }
          }
        }
        
        // Fallback: if we can't determine declarer properly, return the final bidder
        console.log('Could not determine declarer properly, using final bidder');
        return finalBidder;
      }

      // Add this method to get the leader (player to left of declarer):
      getLeader() {
        const declarer = this.getDeclarer();
        const leader = (declarer + 1) % 4;
        
        console.log('Declarer:', ['N','E','S','W'][declarer], 'Leader:', ['N','E','S','W'][leader]);
        return leader;
      }
      
      reset() {
        this.playSequence = [];
        this.playedBy = [];
        this.currentPlayer = this.getLeader(); // Use correct leader
        this.currentTrick = 0;
        this.currentTrickCards = [];
        this.leadSuit = null;
        this.clearCenterCards();
        this.renderBBOHands();
        this.updateBBODisplay();
        this.updateSequenceDisplay();
      }
      
      completeTrick() {
        // Determine winner of the trick
        let winningCardIndex = 0;
        let winningCard = this.currentTrickCards[0];
        
        // Calculate who led this trick
        const trickLeader = (this.currentPlayer + 1) % 4; // Move up 1 positions
        
        console.log('Completing trick:', this.currentTrickCards);
        console.log('Lead suit:', this.leadSuit, 'Trump suit:', this.trumpSuit);
        console.log('Trick leader:', ['N','E','S','W'][trickLeader]);
        
        // Find the highest card that follows suit, or highest trump
        for (let i = 1; i < this.currentTrickCards.length; i++) {
          const card = this.currentTrickCards[i];
          const cardSuit = card[0];
          const cardRank = card[1];
          
          // if curr card is the same suit as the curr winning card
          if (cardSuit == winningCard[0]) {
            // Same suit - higher rank wins
            if (this.getRankValue(cardRank) > this.getRankValue(winningCard[1])) {
              winningCard = card;
              winningCardIndex = i;
            }
          } 
          // else if trumpsuit is not null
          else if (this.trumpSuit && cardSuit === this.trumpSuit) {
            // Trump card beats non-trump
            winningCard = card;
            winningCardIndex = i;
          }
        }
        
        // Calculate who actually won (leader + winning card index)
        const actualWinner = (trickLeader + winningCardIndex) % 4;
        
        console.log('Winning card:', winningCard, 'played by:', ['N','E','S','W'][actualWinner]);
        
        // Winner leads next trick
        this.currentPlayer = actualWinner;
        console.log('next trick by:',actualWinner);

        this.currentTrick += 1;
        this.currentTrickCards = [];
        this.leadSuit = null;
        
        this.clearCenterCards();
        this.updateBBODisplay();
        this.renderBBOHands();
      }

      updateSequenceDisplay() {
        const display = $('#playSequenceDisplay');
        if (this.playSequence.length === 0) {
          display.textContent = 'No cards played yet';
        } else {
          display.textContent = this.playSequence.join(' ');
        }
      } 
    parseExistingPlay(playString) {
      this.playSequence = [];
      this.playedBy = [];
      this.currentTrick = 0;
      this.currentTrickCards = [];
      this.currentPlayer = this.getLeader(); // Use correct leader
      this.leadSuit = null;
      
      if (!playString) {
        this.updateSequenceDisplay();
        return;
      }
      
      playString = playString.replace(/10/g, 't');

      
      // Parse cards like "sj sq sk sa" or "sjsqsksa"
      let cards = [];
      if (playString.includes(' ')) {
        cards = playString.split(' ').filter(c => c.length === 2);
      } else {
        for (let i = 0; i < playString.length; i += 2) {
          if (i + 1 < playString.length) {
            cards.push(playString.substr(i, 2));
          }
        }
      }
      
      cards.forEach((card, cardIndex) => {
        if (card && card.length === 2) {
          this.playSequence.push(card);
          this.playedBy.push(this.currentPlayer);
          this.currentTrickCards.push(card);
          
          if (this.currentTrickCards.length === 1) {
            this.leadSuit = card[0];
          }
          
          if (this.currentTrickCards.length === 4) {
            this.completeTrick();
          } else {
            this.nextPlayer();
          }
        }
      });
      
      this.updateSequenceDisplay();
    }
    open() {
      // Get hands from main form
      this.hands.n = normalizeHand($('#nHand').value);
      this.hands.e = normalizeHand($('#eHand').value);
      this.hands.s = normalizeHand($('#sHand').value);
      this.hands.w = normalizeHand($('#wHand').value);
      
      // Calculate missing hand if any
      this.calculateMissingHand();
      
      // Get the correct leader based on auction
      this.currentPlayer = this.getLeader();
      
      // Get existing play sequence from main form
      const existingPlay = $('#play').value.trim();
      console.log('Loading existing play:', existingPlay);
      
      // Parse existing play sequence
      this.parseExistingPlay(existingPlay);
      
      this.renderBBOHands();
      this.updateBBODisplay();
      $('#playRecorderOverlay').style.display = 'flex';
    }
    applyToMainForm() {
      $('#play').value = this.playSequence.join(' ');
      $('#play').dispatchEvent(new Event('input'));
      this.close();
    }

      close() {
        $('#playRecorderOverlay').style.display = 'none';
      }
    }

    // Initialize play recorder
    const playRecorder = new PlayRecorder();

    // ======= Wire up events =======
    $('#btnParse').addEventListener('click', parseLink);
    $('#btnApply').addEventListener('click', ()=>{ buildUrl(); applyToViewer(); });
    $('#btnCopy').addEventListener('click', async ()=>{
      const v = $('#outputLink').value;
      if(!v) return;
      try{ await navigator.clipboard.writeText(v);
        $('#btnCopy').textContent = 'Copied!';
        setTimeout(()=>$('#btnCopy').textContent='Copy',1200);
      }catch{}
    });
    $('#btnExample').addEventListener('click', ()=>{
      const example = 'https://www.bridgebase.com/tools/handviewer.html?lin='
        + encodeURIComponent('md|1S2389JHTD3JC237KA,S7TH4QKD678TC4569,S456KAH25D25KACJQ,|rh||ah|Board 7|sv|b|mb|p|mb|p|mb|1S|mb|2H|mb|3S|mb|p|mb|4D|mb|p|mb|4S|mb|p|mb|p|mb|p|pg||pc|SQ|pc|S2|pc|S7|pc|SA|pg||pc|SK|pc|H3|pc|S8|pc|ST|pg||pc|CQ|pc|C8|pc|C2|pc|C4|pg||pc|CJ|pc|CT|pc|C3|pc|C5|pg||mc|13|');
      $('#inputLink').value = example;
      parseLink();
    });

    ['#nHand','#eHand','#sHand','#wHand','#auction','#play','#dealer','#vul','#board','#claim']
      .forEach(id => $(id).addEventListener('input', applyDebounced));

    // NEW: preview width control (right panel)
    const widthRange = $('#widthRange');
    const container = $('#container');
    widthRange.addEventListener('input', ()=>{
      const v = +widthRange.value;
      $('#widthVal').textContent = v + '%';
      // set a custom property so media queries can still re-layout on mobile
      container.style.setProperty('--right', v + '%');
    });

    // Initialize URL + preview + width label
    (function init(){
      $('#widthVal').textContent = widthRange.value + '%';
      buildUrl();
      // don't auto-load a blank iframe until user edits or parses
    })();
  </script>
</body>
</html>
